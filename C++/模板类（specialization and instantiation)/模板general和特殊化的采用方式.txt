#include <iostream>

using namespace std;

template <typename T, int n = 0>
class base1
{
private:
    T m_value;
public:
    void show();
};

template <typename T, int n>
void base1<T, n>::show()
{
    cout<<n<<'\t'<<sizeof(T)<<endl;
}

template <typename T>
class base1<T, 0>
{
private:
    int specialized;
    T m_value;
public:
    void show();
};

template <typename T>
void base1<T, 0>::show()
{
    cout<<"specialized!\n";
    cout<<'0'<<'\t'<<sizeof(T)<<endl;
}





int main()
{
    int a;
    base1<double> object;
    object. show();
}



base1<double> 先访问general， 变成base1<double , 0> 然后访问specialized template， 发现base1<double , 0>符合specialized template， 所以调用该类，而不是general template类。